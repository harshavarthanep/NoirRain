<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Noir Rain</title>
    <meta name="theme-color" content="#000000">
    <meta name="description" content="An atmospheric falling game.">
    
    <link rel="manifest" href="manifest.json?v=1" id="manifest-placeholder">

    <style>
        :root {
            --bg-color: #000000;
            --rain-color: #ffffff;
            --hero-color: #ff6600; /* Bright Orange */
            --ui-font: 'Courier New', Courier, monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--ui-font);
            touch-action: none;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-weight: bold;
            font-size: 1.2rem;
            color: #fff;
        }

        #score-display {
            color: var(--hero-color);
            text-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            text-align: center;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 5px;
            border-bottom: 3px solid var(--hero-color);
            display: inline-block;
            padding-bottom: 10px;
        }

        p { color: #aaa; margin-bottom: 2rem; max-width: 300px; line-height: 1.5; font-size: 0.9rem;}

        button {
            background: transparent;
            color: var(--hero-color);
            border: 1px solid var(--hero-color);
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: var(--ui-font);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.2s;
            margin: 10px;
        }

        button:active { transform: scale(0.95); background: rgba(255, 102, 0, 0.1); }

        #sound-btn {
            pointer-events: auto;
            background: none;
            border: 1px solid #555;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            cursor: pointer;
            color: #888;
            padding: 0;
        }

        #tutorial {
            position: absolute;
            bottom: 15%;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            letter-spacing: 1px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0% { opacity: 0.3; } 50% { opacity: 1; text-shadow: 0 0 5px #fff;} 100% { opacity: 0.3; } }

        /* INSTALL POPUP */
        #install-modal {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 400px; background: #111; padding: 20px;
            border: 1px solid var(--hero-color); text-align: center; z-index: 1000;
            display: none; color: white;
        }
        #install-modal h3 { margin-top: 0; color: var(--hero-color); font-weight: normal;}
        #install-btn { background: var(--hero-color); color: #000; border: none; padding: 10px 20px; width: 100%; margin-top: 10px; font-weight: bold;}
        #close-install { position: absolute; top: 10px; right: 15px; cursor: pointer; color: #888; }
        .ios-instructions { font-size: 0.8rem; color: #888; margin-top: 10px; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <span id="score-display">DEPTH: 0m</span>
            <button id="sound-btn">ðŸ”Š</button>
        </div>
        <div id="tutorial" class="hidden">DRAG TO MOVE<br>HOLD TO DIVE</div>
    </div>

    <div id="start-screen" class="screen">
        <h1>NOIR RAIN</h1>
        <p>The Atmospheric Fall. <br>Drag left/right to glide. <br>Hold screen to close umbrella and dive.</p>
        <button onclick="startGame()">JUMP</button>
        <button id="menu-install-btn" class="hidden" style="border-color: #555; color: #fff;">INSTALL GAME</button>
        <p style="font-size: 0.7rem; margin-top: 30px; color: #444;">v1.0.0 | H24 Creationz</p>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #fff; border-color: #fff;">SPLAT</h1>
        <p>DEPTH REACHED: <span id="final-score" style="color: var(--hero-color);">0</span>m</p>
        <p>MAX DEPTH: <span id="best-score" style="color: #fff;">0</span>m</p>
        <button onclick="startGame()">RETRY</button>
        <button onclick="showHome()" style="border-color: #555; color: #aaa;">MENU</button>
    </div>

    <script>
        /** ENGINE CONFIG **/
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = 'MENU'; 
        let score = 0; // Represents depth
        let frames = 0;
        let highScore = localStorage.getItem('noir_rain_highscore') || 0;
        let soundEnabled = true;
        let audioCtx;
        let rainNoiseNode;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(gameState === 'PLAYING' && player) {
                player.y = canvas.height * 0.2; // Keep player near top
            }
        }
        window.addEventListener('resize', resize);
        resize();

        /** GAME OBJECTS **/
        const player = {
            x: canvas.width / 2,
            y: canvas.height * 0.2,
            targetX: canvas.width / 2,
            radiusOpen: 35,
            radiusClosed: 10,
            currentRadius: 35,
            isDiving: false,
            color: '#ff6600'
        };

        let girders = [];
        let raindrops = [];
        let debris = [];
        let baseSpeed = 4;

        /** AUDIO SYSTEM (Procedural Rain) **/
        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }
        }

        function createRainNoise() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 2; // 2 seconds of noise
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1; // White noise
            }

            rainNoiseNode = audioCtx.createBufferSource();
            rainNoiseNode.buffer = buffer;
            rainNoiseNode.loop = true;

            // Filter to make it sound like rain (hiss)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.1;

            rainNoiseNode.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            rainNoiseNode.start();
        }

        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'dive') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'crash') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(20, now + 0.5);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
                if (rainNoiseNode) rainNoiseNode.stop();
            }
        }

        document.getElementById('sound-btn').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-btn').innerText = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
            initAudio();
        });

        /** GAME LOGIC **/
        function spawnGirder() {
            let gapSize = player.radiusOpen * 3.5; // Gap wide enough for open umbrella
            if (Math.random() > 0.7) {
                // Occasional narrow gap requiring diving
                gapSize = player.radiusClosed * 4; 
            }

            let gapX = Math.random() * (canvas.width - gapSize);

            girders.push({
                y: canvas.height + 50,
                gapX: gapX,
                gapSize: gapSize,
                height: 30,
                passed: false
            });
        }

        function initRain() {
            raindrops = [];
            for(let i=0; i<100; i++) {
                raindrops.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    length: Math.random() * 20 + 10,
                    speed: Math.random() * 5 + 10
                });
            }
        }

        function createDebris(x, y, color) {
            for (let i = 0; i < 20; i++) {
                debris.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0, color: color, size: Math.random() * 4 + 2
                });
            }
        }

        function startGame() {
            initAudio();
            if (soundEnabled) createRainNoise();
            
            gameState = 'PLAYING';
            score = 0;
            frames = 0;
            baseSpeed = 4;
            girders = [];
            debris = [];
            initRain();
            
            player.x = canvas.width / 2;
            player.targetX = canvas.width / 2;
            player.isDiving = false;
            player.currentRadius = player.radiusOpen;
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('tutorial').classList.remove('hidden');
            
            loop();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            playSound('crash');
            createDebris(player.x, player.y, player.color);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('noir_rain_highscore', highScore);
            }

            saveScoreToCloud(Math.floor(score));

            document.getElementById('final-score').innerText = Math.floor(score);
            document.getElementById('best-score').innerText = Math.floor(highScore);
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function showHome() {
            gameState = 'MENU';
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
        }

        /** OPTIONAL FIREBASE SETUP **/
        /*
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        
        const app = initializeApp({...}); 
        const db = getFirestore(app);
        const auth = getAuth(app);
        signInAnonymously(auth);
        */

        function saveScoreToCloud(finalScore) {
            console.log("Local save. Firebase disabled.");
            /*
            const user = auth.currentUser;
            if (user) {
                addDoc(collection(db, "leaderboard"), {
                    uid: user.uid, score: finalScore, game: "NoirRain", date: serverTimestamp()
                }).catch(e => console.error(e));
            }
            */
        }

        /** MAIN LOOP **/
        function loop() {
            if (gameState !== 'PLAYING') return;
            requestAnimationFrame(loop);
            frames++;

            // Dynamic Speed
            let currentSpeed = player.isDiving ? baseSpeed * 2.5 : baseSpeed;
            score += currentSpeed * 0.01; // Increase depth

            // Clear Screen with slight fade for trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update Score HUD
            if (frames % 10 === 0) {
                document.getElementById('score-display').innerText = `DEPTH: ${Math.floor(score)}m`;
            }

            // Draw Rain
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            raindrops.forEach(drop => {
                drop.y += drop.speed + currentSpeed;
                if(drop.y > canvas.height) {
                    drop.y = -drop.length;
                    drop.x = Math.random() * canvas.width;
                }
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x, drop.y + drop.length);
            });
            ctx.stroke();

            // Player Logic
            // Smooth horizontal movement (Lerp)
            player.x += (player.targetX - player.x) * 0.15;
            
            // Umbrella state transition
            let targetRadius = player.isDiving ? player.radiusClosed : player.radiusOpen;
            player.currentRadius += (targetRadius - player.currentRadius) * 0.2;

            // Draw Player (Umbrella)
            ctx.shadowBlur = 15;
            ctx.shadowColor = player.color;
            ctx.fillStyle = player.color;
            ctx.beginPath();
            if (player.isDiving) {
                // Draw closed umbrella (triangle/bullet shape)
                ctx.moveTo(player.x, player.y - 15);
                ctx.lineTo(player.x - player.currentRadius, player.y + 15);
                ctx.lineTo(player.x + player.currentRadius, player.y + 15);
            } else {
                // Draw open umbrella (semicircle)
                ctx.arc(player.x, player.y, player.currentRadius, Math.PI, 0);
            }
            ctx.fill();
            ctx.shadowBlur = 0; // Reset

            // Draw Player stick/body
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(player.x, player.y + 25);
            ctx.stroke();

            // Spawn Girders
            if (frames % Math.floor(100 / (currentSpeed/baseSpeed)) === 0) {
                spawnGirder();
                baseSpeed += 0.05; // Slowly increase difficulty
            }

            // Update & Draw Girders
            for (let i = girders.length - 1; i >= 0; i--) {
                let g = girders[i];
                g.y -= currentSpeed;

                // Draw solid black shapes with white outlines
                ctx.fillStyle = '#111';
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 2;

                // Left Rect
                ctx.fillRect(0, g.y, g.gapX, g.height);
                ctx.strokeRect(0, g.y, g.gapX, g.height);

                // Right Rect
                ctx.fillRect(g.gapX + g.gapSize, g.y, canvas.width - (g.gapX + g.gapSize), g.height);
                ctx.strokeRect(g.gapX + g.gapSize, g.y, canvas.width - (g.gapX + g.gapSize), g.height);

                // Collision Detection
                // Check if player Y intersects girder Y
                if (player.y + 15 > g.y && player.y - 15 < g.y + g.height) {
                    // Check if player X is outside the gap (taking radius into account)
                    if (player.x - player.currentRadius < g.gapX || 
                        player.x + player.currentRadius > g.gapX + g.gapSize) {
                        gameOver();
                        return;
                    }
                }

                // Remove off screen
                if (g.y + g.height < 0) {
                    girders.splice(i, 1);
                }
            }

            // Debris (Game Over effect)
            debris.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1.0;
                if (p.life <= 0) debris.splice(i, 1);
            });
        }

        /** INPUT EVENTS **/
        function setPlayerTarget(clientX) {
            player.targetX = clientX;
            // Keep within bounds
            if (player.targetX < 20) player.targetX = 20;
            if (player.targetX > canvas.width - 20) player.targetX = canvas.width - 20;
        }

        function startDive() {
            if(gameState !== 'PLAYING') return;
            player.isDiving = true;
            document.getElementById('tutorial').classList.add('hidden');
            playSound('dive');
        }

        function endDive() {
            player.isDiving = false;
        }

        // Mouse/Touch Tracking for X movement
        window.addEventListener('mousemove', (e) => setPlayerTarget(e.clientX));
        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            setPlayerTarget(e.touches[0].clientX);
        }, {passive: false});

        // Click/Touch for Diving (Closing Umbrella)
        window.addEventListener('mousedown', startDive);
        window.addEventListener('mouseup', endDive);
        window.addEventListener('touchstart', startDive, {passive: false});
        window.addEventListener('touchend', endDive);

    </script>

    <div id="install-modal">
        <span id="close-install" onclick="closeInstallModal()">X</span>
        <h3>INSTALL APP</h3>
        <p style="color: #aaa;">Install Noir Rain to your home screen.</p>
        <button id="install-btn" class="hidden">INSTALL NOW</button>
        <div id="ios-prompt" class="hidden ios-instructions">
            To install on iPhone:<br>
            1. Tap <strong>Share</strong> <br>
            2. Tap <strong>Add to Home Screen</strong>
        </div>
    </div>
    
    <script>
        let deferredPrompt;
        const installModal = document.getElementById('install-modal');
        const installBtn = document.getElementById('install-btn');
        const iosPrompt = document.getElementById('ios-prompt');
        const menuInstallBtn = document.getElementById('menu-install-btn');
    
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(err => console.log('SW failed: ', err));
            });
        }
    
        const isIos = () => /iphone|ipad|ipod/.test(window.navigator.userAgent.toLowerCase());
        const isInStandaloneMode = () => ('standalone' in window.navigator) && (window.navigator.standalone);
    
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installModal.style.display = 'block';
            installBtn.classList.remove('hidden');
            menuInstallBtn.classList.remove('hidden');
            installBtn.addEventListener('click', triggerInstall);
            menuInstallBtn.addEventListener('click', triggerInstall);
        });
        
        function triggerInstall() {
            installModal.style.display = 'none';
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') menuInstallBtn.classList.add('hidden');
                    deferredPrompt = null;
                });
            }
        }
    
        if (isIos() && !isInStandaloneMode()) {
            installModal.style.display = 'block';
            installBtn.classList.add('hidden');
            iosPrompt.classList.remove('hidden');
        }
        function closeInstallModal() { installModal.style.display = 'none'; }
    </script>  
</body>
</html>
